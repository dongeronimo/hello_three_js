<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive cubes (gpu)</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

		<style>
			body {
				background-color: #000;
				color: #444;
			}
			a {
				color: #08f;
			}
		</style>
	</head>
	<body>

        <div id="container"></div>
        <script src="loader.js"></script>
		<script type="module">
			import * as THREE from '../build/three.module.js';
            import { FBXLoader } from './jsm/loaders/FBXLoader.js';
			import { TrackballControls } from './jsm/controls/TrackballControls.js';
            import { BufferGeometryUtils } from './jsm/utils/BufferGeometryUtils.js';

            //Percorre recursivamente a arvore de objetos. Em cada objeto cria um material cuja cor é o id do objeto, guarda
            //o material anterior do objeto (em oldMaterial) e atribui o material do id ao material do objeto.
            const changeMaterialToIdMaterial = (obj)=>{
                obj.children.forEach(child=>{
                    const id = child.id;
                    const oldMaterial = child.material;
                    if(oldMaterial){//Existem objs sem material como os bones que controlam os bonecos, luzes, etc.. não há pq mexer neles pq eles não são clicáveis
                        child.oldMaterial = oldMaterial
                        var idMaterial = new THREE.MeshBasicMaterial( { color: id } );
                        if(oldMaterial.skinning === true){
                            idMaterial.skinning = true;
                        }
                        child.material = idMaterial;
                    }
                    changeMaterialToIdMaterial(child)
                });
            }
            const changeMaterialToOriginalMaterial = (obj)=>{
                obj.children.forEach(child=>{
                    if(child.material){
                        child.material = child.oldMaterial;
                    }
                    changeMaterialToOriginalMaterial(child);
                });
            }


			let container;
			let camera, controls, scene, renderer;
			let pickingTexture, pickingScene;
			let highlightBox;
			const pickingData = [];
			const mouse = new THREE.Vector2();
            const offset = new THREE.Vector3( 10, 10, 10 );
            const clock = new THREE.Clock();
            let mixer = undefined 
			init();
			animate();
			function init() {
                
				container = document.getElementById( "container" );
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1000;
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 );
				pickingScene = new THREE.Scene();
				pickingTexture = new THREE.WebGLRenderTarget( 1, 1 );
				scene.add( new THREE.AmbientLight( 0x555555 ) );
				const light = new THREE.SpotLight( 0xffffff, 1.5 );
				light.position.set( 0, 500, 2000 );
				scene.add( light );
				const pickingMaterial = new THREE.MeshBasicMaterial( { vertexColors: true } );
				const defaultMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true, vertexColors: true, shininess: 0	} );
				function applyVertexColors( geometry, color ) {
					const position = geometry.attributes.position;
					const colors = [];
					for ( let i = 0; i < position.count; i ++ ) {
						colors.push( color.r, color.g, color.b );
					}
					geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
                }
                
  
        
                let bonecoAnimation = undefined;
                let cubo = undefined;
                let plano = undefined;
                let boneco = undefined;
                new MyLoader(THREE, FBXLoader, (object)=>{
                    //Adiciona à cena que é renderizada
                    scene.add(object);
                    plano = object.children.filter((childObject)=>childObject.name=="Plano")[0];
                    cubo = object.children.filter((childObject)=>childObject.name=="Cubo")[0];
                    boneco = object.getObjectByName("boneco");
                    plano.visible = false;  
                    cubo.visible = false;
                    mixer = new THREE.AnimationMixer(object);
                    bonecoAnimation = mixer.clipAction(object.animations[0]);
                    bonecoAnimation.play();
                    //Adiciona à cena de picking
                }, (progressPercentage)=>{console.log(progressPercentage)}).load('./assets/untitled.fbx')

				// const geometriesDrawn = [];
				// const geometriesPicking = [];
				// const matrix = new THREE.Matrix4();
				// const quaternion = new THREE.Quaternion();
				// const color = new THREE.Color();
				// for ( let i = 0; i < 5000; i ++ ) {
				// 	let geometry = new THREE.BoxBufferGeometry();
				// 	const position = new THREE.Vector3();
				// 	position.x = Math.random() * 10000 - 5000;
				// 	position.y = Math.random() * 6000 - 3000;
				// 	position.z = Math.random() * 8000 - 4000;
				// 	const rotation = new THREE.Euler();
				// 	rotation.x = Math.random() * 2 * Math.PI;
				// 	rotation.y = Math.random() * 2 * Math.PI;
				// 	rotation.z = Math.random() * 2 * Math.PI;
				// 	const scale = new THREE.Vector3();
				// 	scale.x = Math.random() * 200 + 100;
				// 	scale.y = Math.random() * 200 + 100;
				// 	scale.z = Math.random() * 200 + 100;
				// 	quaternion.setFromEuler( rotation );
				// 	matrix.compose( position, quaternion, scale );
				// 	geometry.applyMatrix4( matrix );
				// 	// give the geometry's vertices a random color, to be displayed
				// 	applyVertexColors( geometry, color.setHex( Math.random() * 0xffffff ) );
				// 	geometriesDrawn.push( geometry );
				// 	geometry = geometry.clone();
				// 	// give the geometry's vertices a color corresponding to the "id"
				// 	applyVertexColors( geometry, color.setHex( i ) );
				// 	geometriesPicking.push( geometry );
				// 	pickingData[ i ] = {
				// 		position: position,
				// 		rotation: rotation,
				// 		scale: scale
				// 	};
				// }
				// const objects = new THREE.Mesh( BufferGeometryUtils.mergeBufferGeometries( geometriesDrawn ), defaultMaterial );
				// scene.add( objects );
				// pickingScene.add( new THREE.Mesh( BufferGeometryUtils.mergeBufferGeometries( geometriesPicking ), pickingMaterial ) );
				// highlightBox = new THREE.Mesh(
				// 	new THREE.BoxBufferGeometry(),
				// 	new THREE.MeshLambertMaterial( { color: 0xffff00 }
				// 	) );
				// scene.add( highlightBox );
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				controls = new TrackballControls( camera, renderer.domElement );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;
				renderer.domElement.addEventListener( 'click', onMouseMove );
			}
			function onMouseMove( e ) {
				mouse.x = e.clientX;
                mouse.y = e.clientY;
                pick()
			}
			function animate() {
				requestAnimationFrame( animate );
				render();
			}
			function pick() {
                changeMaterialToIdMaterial(scene);
                //render the picking scene off-screen
                // // set the view offset to represent just a single pixel under the mouse
                camera.setViewOffset( renderer.domElement.width, renderer.domElement.height, mouse.x * window.devicePixelRatio | 0, mouse.y * window.devicePixelRatio | 0, 1, 1 );
                // // render the scene
                renderer.setRenderTarget(pickingTexture);
                renderer.render(scene, camera);
                // // clear the view offset so rendering returns to normal
                camera.clearViewOffset();
                // //create buffer for reading single pixel
                const pixelBuffer = new Uint8Array( 4 );
                renderer.readRenderTargetPixels( pickingTexture, 0, 0, 1, 1, pixelBuffer );
                console.log(pixelBuffer)
                changeMaterialToOriginalMaterial(scene);
				// //render the picking scene off-screen
				// // set the view offset to represent just a single pixel under the mouse
				// camera.setViewOffset( renderer.domElement.width, renderer.domElement.height, mouse.x * window.devicePixelRatio | 0, mouse.y * window.devicePixelRatio | 0, 1, 1 );
				// // render the scene
				// renderer.setRenderTarget( pickingTexture );
				// renderer.render( pickingScene, camera );
				// // clear the view offset so rendering returns to normal
				// camera.clearViewOffset();
				// //create buffer for reading single pixel
				// const pixelBuffer = new Uint8Array( 4 );
				// //read the pixel
                // renderer.readRenderTargetPixels( pickingTexture, 0, 0, 1, 1, pixelBuffer );
                // console.log(pixelBuffer)
				// //interpret the pixel as an ID
				// const id = ( pixelBuffer[ 0 ] << 16 ) | ( pixelBuffer[ 1 ] << 8 ) | ( pixelBuffer[ 2 ] );
				// const data = pickingData[ id ];
				// if ( data ) {
				// 	//move our highlightBox so that it surrounds the picked object
				// 	if ( data.position && data.rotation && data.scale ) {
				// 		highlightBox.position.copy( data.position );
				// 		highlightBox.rotation.copy( data.rotation );
				// 		highlightBox.scale.copy( data.scale ).add( offset );
				// 		highlightBox.visible = true;
				// 	}
				// } else {
				// //	highlightBox.visible = false;
				// }
            }
            
			function render() {
				controls.update();
                //pick();
                const delta = clock.getDelta();
                if(mixer){
                    mixer.update(delta);
                }
				renderer.setRenderTarget( null );
				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>

